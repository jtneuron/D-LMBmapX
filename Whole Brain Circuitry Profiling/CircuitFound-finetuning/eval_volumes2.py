from myutils import *
import pdb
import pandas as pd
import argparse
from tqdm import tqdm


def eval_two_volume_dirs_maxpool(target, root, data, pool_kernel, device):

    if 'trailmap' in root:
        label = read_tiff_stack(join(target, data))
        pre = read_tiff_stack(join(root, 'seg-volume-' + data.split('-')[2]))
    if 'soma' in root:
        if 'OURS' in root:
            label = read_nifti(join(target, data))
            pre = read_nifti(join(root, 'volume-' + data.split('-')[1]))
        elif 'ACE' in root:
            label = read_tiff_stack(join(target, data))
            pre = read_tiff_stack(join(root, 'out_volume-' + data.split('-')[1]))
        elif 'Stardist' in root:
            label = read_tiff_stack(join(target, data))
            pre = read_tiff_stack(join(root, 'volume-' + data.split('-')[1]))
        else:
            label = read_tiff_stack(join(target, data))
            pre = read_tiff_stack(join(root, data))
    else:
        label = read_nifti(join(target, data))
        pre = read_nifti(join(root, 'volume-' + data.split('-')[2]))

    k = pool_kernel
    # s = max(1, k - 1)
    kernel = (k, k, k)
    # stride = (s, s, s)
    pre[pre > 0] = 1
    label[label > 0] = 1
    pre = pre.astype(np.uint8)
    label = label.astype(np.uint8)

    pre = torch.Tensor(pre).view((1, 1, *pre.shape)).to(device)
    label = torch.Tensor(label).view((1, 1, *label.shape)).to(device)

    pre = torch.nn.functional.max_pool3d(pre, kernel, 1, 0)
    label = torch.nn.functional.max_pool3d(label, kernel, 1, 0)

    dice_score = dice_error(pre, label)

    total_loss_iou = iou(pre, label).cpu()
    total_loss_tiou = t_iou(pre, label).cpu()
    clrecall, clprecision, recall, precision = soft_cldice_f1(pre, label)
    cldice = (2. * clrecall * clprecision) / (clrecall + clprecision)
    acc = calculate_accuracy(pre, label)

    # print('\n Sub Validation IOU: {}\n T-IOU: {}'
    #       '\n ClDice: {} \n clprecision: {} \n ClRecall: {} \n Dice-score: {}'
    #       '\n precision: {} \n Recall: {}'
    #       .format(total_loss_iou, total_loss_tiou, cldice, clprecision, clrecall, dice_score, precision, recall, ':.8f'))
    return {'iou': total_loss_iou,
            'tiou': total_loss_tiou,
            'cldice': cldice,
            'clprecision': clprecision,
            'clrecall': clrecall,
            'dice': dice_score,
            'precision': precision,
            'recall': recall,
            'acc': acc}


def avg(num, total):
    return total / num


if __name__ == "__main__":
    # ========== evaluate only one cube of 600*600*450 ========== #
    parser = argparse.ArgumentParser()
    parser.add_argument('--target', type=str, default=None, help='grould-truth label of 600*600*450 cube for evaluation')
    parser.add_argument('--root', type=str, default=None, help='data with nnUNet prediction generated by `nnUNet_predict` command')
    parser.add_argument('--kernel_size', type=int, default=3, help='maxpooling kernel size 5,10,15')

    args = parser.parse_args()
    device = torch.device('cuda:2')

    # ========================================== Based on all volumes =================================================
    iou_1, tiou_1, cldice_1, clprecision_1, clrecall_1, dice_score_1, recall_1, precision_1, acc_1 = 0, 0, 0, 0, 0, 0, 0, 0, 0
    count = 0

    for data in sorted(os.listdir(args.target)):
        if "12847" in data or "280506" in data or "12816" in data:
            continue
        if ".nii.gz" in data or ".tif" in data or ".tiff" in data:
            count += 1
            loss = eval_two_volume_dirs_maxpool(args.target, args.root, data, args.kernel_size, device)
            iou_1 += loss['iou']
            tiou_1 += loss['tiou']
            cldice_1 += loss['cldice']
            clprecision_1 += loss['clprecision']
            clrecall_1 += loss['clrecall']
            dice_score_1 += loss['dice']
            recall_1 += loss['recall']
            precision_1 += loss['precision']
            acc_1 += loss['acc']
            # print("acc: {}".format(acc_1))
    iou_t = avg(count, iou_1)
    tiou_t = avg(count, tiou_1)
    cldice_t = avg(count, cldice_1)
    clprecision_t = avg(count, clprecision_1)
    clrecall_t = avg(count, clrecall_1)
    score_t = avg(count, dice_score_1)
    recall_t = avg(count, recall_1)
    precision_t = avg(count, precision_1)
    acc_t = avg(count, acc_1)
    print('\n Validation IOU: {}\n T-IOU: {}'
          '\n ClDice: {} \n ClPrecision: {} \n ClRecall: {} \n Dice-score: {} \n Precision: {} \n Recall: {} \n Acc: {}'
          .format(iou_t, tiou_t, cldice_t, clprecision_t, clrecall_t, score_t, precision_t, recall_t, acc_t, '.8f'))

    # ========================================== Based on Stage =================================================
    # # stages = ['28', '21', '14', '10']
    # stages = ['7', '4', '0']
    # stages_dict = {}
    # for stage in stages:
    #     region_volume_list = []
    #     for data in sorted(os.listdir(args.target)):
    #         if "12847" in data or "280506" in data or "12816" in data:
    #             continue
    #         if 'volume-' + stage in data:
    #             region_volume_list.append(data)
    #         if stage == '28' and 'volume-128' in data:
    #             region_volume_list.append(data)
    #         if stage == '0' and 'volume-6' in data:
    #             region_volume_list.append(data)
    #     stages_dict[stage] = region_volume_list
    #
    # print(stages_dict)
    #
    # for stage in stages:
    #     iou_1, tiou_1, cldice_1, clprecision_1, clrecall_1, dice_score_1, recall_1, precision_1, acc_1 = 0, 0, 0, 0, 0, 0, 0, 0, 0
    #     count = 0
    #     for data in stages_dict[stage]:
    #         if ".nii.gz" in data or ".tif" in data or ".tiff" in data:
    #             count += 1
    #             loss = eval_two_volume_dirs_maxpool(args.target, args.root, data, args.kernel_size, device)
    #             iou_1 += loss['iou']
    #             tiou_1 += loss['tiou']
    #             cldice_1 += loss['cldice']
    #             clprecision_1 += loss['clprecision']
    #             clrecall_1 += loss['clrecall']
    #             dice_score_1 += loss['dice']
    #             recall_1 += loss['recall']
    #             precision_1 += loss['precision']
    #             acc_1 += loss['acc']
    #
    #     iou_t = avg(count, iou_1)
    #     tiou_t = avg(count, tiou_1)
    #     cldice_t = avg(count, cldice_1)
    #     clprecision_t = avg(count, clprecision_1)
    #     clrecall_t = avg(count, clrecall_1)
    #     score_t = avg(count, dice_score_1)
    #     recall_t = avg(count, recall_1)
    #     precision_t = avg(count, precision_1)
    #     acc_t = avg(count, acc_1)
    #     print('=================== {} ====================='.format('P' + stage))
    #     print('Validation IOU: {}\n T-IOU: {}'
    #           '\n ClDice: {} \n ClPrecision: {} \n ClRecall: {} \n Dice-score: {} \n Precision: {} \n Recall: {} \n Acc: {}\n'
    #           .format(iou_t, tiou_t, cldice_t, clprecision_t, clrecall_t, score_t, precision_t, recall_t, acc_t, '.8f'))

    # =========================================== Based on Brain Regions ==============================================
    # brain_regions = ['BS', 'CB', 'CTX', 'HPF']
    # brain_regions_dict = {}
    # for brain_region in brain_regions:
    #     region_volume_list = []
    #     for data in sorted(os.listdir(args.target)):
    #         if "12847" in data or "280506" in data or "12816" in data:
    #             continue
    #         if brain_region in data:
    #             region_volume_list.append(data)
    #     brain_regions_dict[brain_region] = region_volume_list
    #
    # print(brain_regions_dict)
    #
    # for brain_region in brain_regions:
    #     iou_1, tiou_1, cldice_1, clprecision_1, clrecall_1, dice_score_1, recall_1, precision_1, acc_1 = 0, 0, 0, 0, 0, 0, 0, 0, 0
    #     count = 0
    #     for data in brain_regions_dict[brain_region]:
    #         if ".nii.gz" in data or ".tif" in data or ".tiff" in data:
    #             count += 1
    #             loss = eval_two_volume_dirs_maxpool(args.target, args.root, data, args.kernel_size, device)
    #             iou_1 += loss['iou']
    #             tiou_1 += loss['tiou']
    #             cldice_1 += loss['cldice']
    #             clprecision_1 += loss['clprecision']
    #             clrecall_1 += loss['clrecall']
    #             dice_score_1 += loss['dice']
    #             recall_1 += loss['recall']
    #             precision_1 += loss['precision']
    #             acc_1 += loss['acc']
    #             # print("acc: {}".format(acc_1))
    #
    #     # print(count)
    #     iou_t = avg(count, iou_1)
    #     tiou_t = avg(count, tiou_1)
    #     cldice_t = avg(count, cldice_1)
    #     clprecision_t = avg(count, clprecision_1)
    #     clrecall_t = avg(count, clrecall_1)
    #     score_t = avg(count, dice_score_1)
    #     recall_t = avg(count, recall_1)
    #     precision_t = avg(count, precision_1)
    #     acc_t = avg(count, acc_1)
    #     print('=================== {} ====================='.format(brain_region))
    #     print('Validation IOU: {}\n T-IOU: {}'
    #           '\n ClDice: {} \n ClPrecision: {} \n ClRecall: {} \n Dice-score: {} \n Precision: {} \n Recall: {} \n Acc: {}\n'
    #           .format(iou_t, tiou_t, cldice_t, clprecision_t, clrecall_t, score_t, precision_t, recall_t, acc_t, '.8f'))


